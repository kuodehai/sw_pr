
总线错误：

          总线错误几乎是由于data的未对齐的读或者写引起的，将他之所以称为是bus error；原因在于出现未对齐的内存的读写访问请求时，被堵塞的组间就是总线错误。对其（alignment）的意思是数据项只能存储在地址是数据项大小的整数倍的内存空间上。现在很多的RISC（

reduced instruction set computer，精简指令集计算机）需要对数据对齐，因为数据的任意的对齐会对内存的空间和逻辑上会出现巨大的影响并使系统的性能和速度上变慢。通过内存对齐是内存的访问局限在一个cache或者单独的段 /页上可以极大的利用内存提高访问的速率和程序的执行速率，也不会出现内存的错乱现象，便于内存的管理。当然一个好的编译器会对内存的不对齐情况会有相应的warning提示。
 
段错误：
        段错误是由于内存管理单元MMU（负责支持虚拟内村的硬件）的异常所致，而该异常则通常是由于解除引用一个未出始化或者非法的指针引起的，如果指针的引用一个并不位于你的地址空间的地址，操作系统会但与此进行干涉，一个小的引起段错误的带码：
       
int* p = 0；p = 88;
一个微妙之处是如果初始化的指针恰好具有未对齐的值，它将产生总线错误而不是段错误，对于绝大多数架构而言cpu先看到地址，再把它发给MMU；另外的一点是,导致指针具有非法的值通常是由于不同的编程错误而引起。和总线不同此时的段错误更像是一个间接的症状引起的。
 
通常情况下导致段错误的几个直接原因：
        1，解除一个包含非法值的指针。
        2，解除引用一个空指针（常常由于从系统程序中返回空指针，并未经过检查就使用）。
        3，在未得到确定的权限时就进行访问，试图在只读的文件上执行写操作是出现段错误。
        4，超出了虚拟内存的大小（4G）；或堆栈空间
已发生的频率为序，最终可能导致段错误的常见编程的错误：
P1: 坏指针错误：在指针之前就用它来引用内存，或者向库函数传送一个坏的指针。导致这种坏指针的原因是对指针进行释放后再去访问它所致。警记：在free之后含要将指针的指向NULL值，free(p); p = NULL;
P2：越过数组的边界写入数据，在动态分配内存时容易出现的额一种问题。
P3：两次释放同一块内存，或者释放未曾malloc过的内存或无效的指针；或者释放这在使用中的内存空间，一个极为常见的释放内存有关的错误语句：
